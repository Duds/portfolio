---
export interface Props {
  class?: string;
}
const { class: className = "" } = Astro.props;
---

<div class={`guilloche-container ${className}`}>
  <canvas id="guilloche-canvas" class="w-full h-full"></canvas>
</div>

<style>
  .guilloche-container {
    width: 100%;
    height: 100%;
    position: relative;
  }
  
  #guilloche-canvas {
    display: block;
  }
</style>

<script>
  class GuillochePattern {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private basePoints: Array<{x: number, y: number}>;
    private orbitData: Array<{radius: number, speed: number, angleOffset: number}>;
    private offsetPaths: Array<Array<{x: number, y: number}>>;
    private numOffsets: number;
    private numPoints: number;
    private offsetDistance: number;
    private minDistance: number;
    private frameCount: number;
    private animationId: number | null;
    
    constructor(canvasId: string) {
      const canvasElement = document.getElementById(canvasId) as HTMLCanvasElement;
      if (!canvasElement) {
        throw new Error(`Canvas element with id '${canvasId}' not found`);
      }
      
      this.canvas = canvasElement;
      const context = this.canvas.getContext('2d');
      if (!context) {
        throw new Error('Could not get 2D context from canvas');
      }
      
      this.ctx = context;
      this.basePoints = [];
      this.orbitData = [];
      this.offsetPaths = [];
      // GUILLOCHE PARAMETERS - Adjust these to modify the pattern
      this.numOffsets = 8;        // Number of offset paths (more = more complex pattern)
      this.numPoints = 4;        // Number of base points (more = more detailed curves)
      this.offsetDistance = 8;    // Distance between offset paths (larger = wider pattern)
      this.minDistance = 50;      // Minimum distance between points (larger = more spread out)
      this.frameCount = 0;
      this.animationId = null;
      
      this.init();
    }
    
    init() {
      this.resize();
      this.generatePoints();
      this.generateOrbitData();
      this.animate();
      
      window.addEventListener('resize', () => {
        this.resize();
        this.generatePoints();
        this.generateOrbitData();
      });
    }
    
    resize() {
      const rect = this.canvas.getBoundingClientRect();
      this.canvas.width = rect.width * window.devicePixelRatio;
      this.canvas.height = rect.height * window.devicePixelRatio;
      this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      this.canvas.style.width = rect.width + 'px';
      this.canvas.style.height = rect.height + 'px';
    }
    
    generatePoints() {
      this.basePoints = [];
      let attempts = 0;
      const safeRadius = Math.min(this.canvas.width, this.canvas.height) / 2 - this.numOffsets * this.offsetDistance - 20;
      
      while (this.basePoints.length < this.numPoints && attempts < 5000) {
        attempts++;
        const angle = Math.random() * Math.PI * 2;
        // PATTERN SIZE PARAMETERS - Controls how large the pattern appears
        const r = safeRadius * 0.8 + (Math.random() - 0.5) * safeRadius * .8;  // Base radius (0.8 = 80% of available space)
        const x = Math.cos(angle) * r + (Math.random() - 0.5) * 80;            // Random offset range (±40px)
        const y = Math.sin(angle) * r + (Math.random() - 0.5) * 80;            // Random offset range (±40px)
        const candidate = { x, y };
        
        const tooClose = this.basePoints.some(p => 
          Math.sqrt((p.x - candidate.x) ** 2 + (p.y - candidate.y) ** 2) < this.minDistance
        );
        
        if (!tooClose) {
          this.basePoints.push(candidate);
        }
      }
    }
    
    generateOrbitData() {
      // ORBIT PARAMETERS - Controls the orbiting motion of each point
      this.orbitData = this.basePoints.map(() => ({
        radius: Math.random() * 20 + 8,           // Orbit radius range (8-28px)
        speed: Math.random() * 0.008 + 0.002,     // Animation speed (0.002-0.01, lower = slower)
        angleOffset: Math.random() * Math.PI * 2  // Random starting angle
      }));
    }
    
    createVector(x: number, y: number): {x: number, y: number} {
      return { x, y };
    }
    
    sub(v1: {x: number, y: number}, v2: {x: number, y: number}): {x: number, y: number} {
      return { x: v1.x - v2.x, y: v1.y - v2.y };
    }
    
    add(v1: {x: number, y: number}, v2: {x: number, y: number}): {x: number, y: number} {
      return { x: v1.x + v2.x, y: v1.y + v2.y };
    }
    
    mult(v: {x: number, y: number}, scalar: number): {x: number, y: number} {
      return { x: v.x * scalar, y: v.y * scalar };
    }
    
    dist(v1: {x: number, y: number}, v2: {x: number, y: number}): number {
      return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2);
    }
    
    normalize(v: {x: number, y: number}): {x: number, y: number} {
      const mag = Math.sqrt(v.x ** 2 + v.y ** 2);
      return { x: v.x / mag, y: v.y / mag };
    }
    
    heading(v: {x: number, y: number}): number {
      return Math.atan2(v.y, v.x);
    }
    
    map(value: number, start1: number, stop1: number, start2: number, stop2: number): number {
      return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
    }
    
    animate() {
      this.frameCount++;
      this.draw();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    draw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.save();
      this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
      
      const curvePoints = this.basePoints.map((pt, i) => {
        const orbit = this.orbitData[i];
        const angle = this.frameCount * orbit.speed + orbit.angleOffset;
        return this.createVector(
          pt.x + Math.cos(angle) * orbit.radius,
          pt.y + Math.sin(angle) * orbit.radius
        );
      });
      
      this.offsetPaths = [];
      
      for (let o = 0; o <= this.numOffsets; o++) {
        const offsetPath = [];
        for (let i = 0; i < curvePoints.length; i++) {
          const curr = curvePoints[i];
          const next = curvePoints[(i + 1) % curvePoints.length];
          const dir = this.heading(this.sub(next, curr));
          const offsetAngle = dir - Math.PI / 2;
          
          const dist = this.offsetDistance * o;
          const ox = Math.cos(offsetAngle) * dist;
          const oy = Math.sin(offsetAngle) * dist;
          
          offsetPath.push(this.createVector(curr.x + ox, curr.y + oy));
        }
        this.offsetPaths.push(offsetPath);
      }
      
      for (let p = 0; p < this.offsetPaths.length; p++) {
        const path = this.offsetPaths[p];
        const hueShift = this.map(p, 0, this.offsetPaths.length, 0, 360);
        // Draw blurred shadow first
        this.ctx.save();
        this.ctx.strokeStyle = `hsl(${hueShift}, 70%, 60%)`;
        this.ctx.lineWidth = 4;
        this.ctx.shadowBlur = 16;
        this.ctx.shadowColor = `hsla(${hueShift}, 70%, 60%, 0.35)`;
        this.ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const prev = path[(i - 1 + path.length) % path.length];
          const curr = path[i];
          const next = path[(i + 1) % path.length];
          const dirPrev = this.normalize(this.sub(curr, prev));
          const dirNext = this.normalize(this.sub(next, curr));
          const handleLen = 0.3 * this.dist(curr, next);
          const control1 = this.add(curr, this.mult(dirPrev, handleLen));
          const control2 = this.sub(next, this.mult(dirNext, handleLen));
          if (i === 0) {
            this.ctx.moveTo(curr.x, curr.y + 2);
          }
          this.ctx.bezierCurveTo(control1.x, control1.y + 2, control2.x, control2.y + 2, next.x, next.y + 2);
        }
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.restore();
        // Draw main path
        this.ctx.save();
        this.ctx.strokeStyle = `hsl(${hueShift}, 70%, 60%)`;
        this.ctx.lineWidth = 1;
        this.ctx.shadowBlur = 0;
        this.ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const prev = path[(i - 1 + path.length) % path.length];
          const curr = path[i];
          const next = path[(i + 1) % path.length];
          const dirPrev = this.normalize(this.sub(curr, prev));
          const dirNext = this.normalize(this.sub(next, curr));
          const handleLen = 0.3 * this.dist(curr, next);
          const control1 = this.add(curr, this.mult(dirPrev, handleLen));
          const control2 = this.sub(next, this.mult(dirNext, handleLen));
          if (i === 0) {
            this.ctx.moveTo(curr.x, curr.y);
          }
          this.ctx.bezierCurveTo(control1.x, control1.y, control2.x, control2.y, next.x, next.y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.restore();
      }
      
      this.ctx.restore();
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }
  
  // Initialize the guilloche pattern when the component loads
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('guilloche-canvas');
    if (canvas) {
      new GuillochePattern('guilloche-canvas');
    }
  });
</script> 