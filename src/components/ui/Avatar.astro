---
export interface Props {
  src?: string;
  alt?: string;
  size?: number;
  initials?: string;
}
const { src, alt = '', size = 40, initials = '' } = Astro.props;
---
{src ? (
  <div class="avatar-gradient-bg relative inline-block" style={`width: ${size}px; height: ${size}px;`} data-avatar-size={size}>
    <svg
      class="avatar-blob absolute z-0"
      width={size * 2}
      height={size * 2}
      style="left: 50%; top: 50%; transform: translate(-50%, -50%); filter: blur(16px); pointer-events: none; position: absolute;"
      viewBox={`0 0 ${size * 2} ${size * 2}`}
    >
      <defs>
        {/* Rainbow radial gradient, r is animated in JS for pulsing effect */}
        <radialGradient id={`rainbowRadial-${size}`} cx="50%" cy="50%" r="35%">
          <stop offset="0%" stop-color="#FF5F6D" />
          <stop offset="20%" stop-color="#FFC371" />
          <stop offset="40%" stop-color="#47EFA6" />
          <stop offset="60%" stop-color="#43C6AC" />
          <stop offset="80%" stop-color="#6A82FB" />
          <stop offset="100%" stop-color="#FF5F6D" />
        </radialGradient>
      </defs>
      {/* The animated blob path is filled with the rainbow gradient */}
      <path
        id={`avatarBlobPath-${size}`}
        fill={`url(#rainbowRadial-${size})`}
      />
    </svg>
    <img
      src={src}
      srcset={src.replace('.png', '.png 1x') + ', ' + src.replace('.png', '@2x.png 2x') + ', ' + src.replace('.png', '@3x.png 3x')}
      sizes={`${size}px`}
      alt={alt}
      width={size}
      height={size}
      class="rounded-full object-cover border border-gray-200 relative z-10"
      loading="lazy"
    />
    <script is:inline>
      // --- Blob Animation Parameters ---
      // outerPoints, innerPoints: number of points for the blob (4 each for 8-pointed shape)
      // baseOuterRadius, baseInnerRadius: base radii for outer/inner points (smaller = more compact blob)
      // outerVariance, innerVariance: how much each point can move in/out (smaller = less spiky)
      // speed: controls morphing speed (lower = slower)
      // globalRotation: controls overall rotation speed
      // The radial gradient's r attribute is animated for a pulsing effect

      const wrapper = document.currentScript.parentElement;
      const size = parseFloat(wrapper.getAttribute('data-avatar-size'));
      const cx = size;
      const cy = size;
      const outerPoints = 4;
      const innerPoints = 4;
      const totalPoints = outerPoints + innerPoints;
      const baseOuterRadius = size * 0.8; // Was 0.95
      const baseInnerRadius = size * 0.58; // Was 0.65
      const outerVariance = size * 0.12; // Was 0.18
      const innerVariance = size * 0.07; // Was 0.10
      const speed = (0.7 + Math.random()) * 0.5; // Halved speed for morphing
      let angles = Array.from({length: totalPoints}, (_, i) => (i / totalPoints) * Math.PI * 2);
      let radii = Array.from({length: totalPoints}, (__, i) => i % 2 === 0 ? baseOuterRadius : baseInnerRadius);
      let angleOffsets = Array.from({length: totalPoints}, () => Math.random() * Math.PI * 2);
      let angleSpeeds = Array.from({length: totalPoints}, () => (Math.random() - 0.5) * 0.008);
      let radiusOffsets = Array.from({length: totalPoints}, () => Math.random() * Math.PI * 2);
      let radiusSpeeds = Array.from({length: totalPoints}, () => (Math.random() - 0.5) * 0.012);
      let globalRotation = 0;
      // Returns a closed Bezier path string for the current blob shape
      function getBezierPath(cx, cy, radii, angles) {
        // Calculate points
        const points = angles.map((a, i) => {
          const r = radii[i];
          return [
            cx + Math.cos(a) * r,
            cy + Math.sin(a) * r
          ];
        });
        // Calculate control points for smooth closed Bezier
        const controls = points.map((p, i, arr) => {
          const prev = arr[(i - 1 + arr.length) % arr.length];
          const next = arr[(i + 1) % arr.length];
          // Control point is halfway between this and next, pulled toward the centre
          const c1 = [
            (p[0] + prev[0]) / 2 + (cx - p[0]) * 0.18,
            (p[1] + prev[1]) / 2 + (cy - p[1]) * 0.18
          ];
          const c2 = [
            (p[0] + next[0]) / 2 + (cx - p[0]) * 0.18,
            (p[1] + next[1]) / 2 + (cy - p[1]) * 0.18
          ];
          return [c1, c2];
        });
        let d = `M${points[0][0]},${points[0][1]}`;
        for (let i = 0; i < points.length; i++) {
          const next = (i + 1) % points.length;
          d += ` C${controls[i][1][0]},${controls[i][1][1]} ${controls[next][0][0]},${controls[next][0][1]} ${points[next][0]},${points[next][1]}`;
        }
        d += 'Z';
        return d;
      }
      // Main animation loop: morphs the blob, pulses the gradient, and rotates the shape
      function animateBlob() {
        const now = Date.now() / 1000;
        // Slowly rotate the entire blob (half speed)
        globalRotation += 0.0015;
        // Animate radial gradient radius (pulse, half speed, smaller span)
        const grad = document.getElementById(`rainbowRadial-${size}`);
        if (grad) {
          // r animates between 25% and 45%
          const pulse = 0.35 + 0.10 * Math.sin(now * 0.6);
          grad.setAttribute('r', `${(pulse * 100).toFixed(1)}%`);
        }
        for (let i = 0; i < totalPoints; i++) {
          // Animate angle with more leeway and global rotation
          angleOffsets[i] += angleSpeeds[i];
          angles[i] = (i / totalPoints) * Math.PI * 2 + Math.sin(now * speed + angleOffsets[i]) * 0.38 + globalRotation;
          // Animate radius
          radiusOffsets[i] += radiusSpeeds[i];
          if (i % 2 === 0) {
            // Outer points
            radii[i] = baseOuterRadius + Math.sin(now * speed * 0.9 + radiusOffsets[i]) * outerVariance;
          } else {
            // Inner points
            radii[i] = baseInnerRadius + Math.sin(now * speed * 1.2 + radiusOffsets[i]) * innerVariance;
          }
        }
        // Ensure outer points always have greater radius than inner points
        for (let i = 0; i < totalPoints; i += 2) {
          if (radii[i] < radii[(i + 1) % totalPoints]) {
            radii[i] = radii[(i + 1) % totalPoints] + size * 0.08;
          }
        }
        // Draw blob
        const path = getBezierPath(cx, cy, radii, angles);
        const el = document.getElementById(`avatarBlobPath-${size}`);
        if (el) el.setAttribute('d', path);
        requestAnimationFrame(animateBlob);
      }
      animateBlob();
    </script>
  </div>
) : (
  <span
    class="inline-flex items-center justify-center rounded-full bg-gray-200 text-gray-600 font-semibold border border-gray-200"
    style={`width: ${size}px; height: ${size}px; font-size: ${size / 2.5}px;`}
    aria-label={alt}
  >
    {initials || '?'}
  </span>
)}
 